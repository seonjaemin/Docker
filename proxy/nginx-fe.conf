user  nginx;
worker_processes  auto;

events { worker_connections  1024; }

http {
  client_max_body_size 50m;	
  ## (시연용) 클라이언트↔Nginx keep-alive 완전 비활성화
  keepalive_timeout 0;

  ## 도커 내장 DNS(필수 아님, 유지해도 무방)
  resolver 127.0.0.11 valid=10s ipv6=off;

  ## 업스트림: 연결 재사용 풀(keepalive N) 없음 → 요청마다 새 연결
  upstream front_pool {
    server frontend-1:8000 max_fails=3 fail_timeout=10s;
    server frontend-2:8000 max_fails=3 fail_timeout=10s;
    server frontend-3:8000 max_fails=3 fail_timeout=10s;
    # least_conn;   # 필요 시 전략 변경
  }

  ## (선택) 업스트림 주소를 로그에 남겨 분산 확인
  log_format upstream '$remote_addr "$request" -> $upstream_addr $status';
  access_log /dev/stdout upstream;

  server {
    listen 80;

    ## 헬스체크
    location = /healthz {
      return 200 'ok';
      add_header Content-Type text/plain;
    }

    location / {
      ## (시연용) 업스트림에 HTTP/1.0 + Connection: close로 보내서
      ##          요청마다 연결을 끊게 함
      proxy_http_version 1.1;
      proxy_set_header Connection "";
      proxy_request_buffering on;

      ## 일반 프록시 헤더
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      ## 버퍼링/타임아웃 (시연 안정화를 위해 약간 타이트)
      proxy_buffering off;
      proxy_read_timeout 30s;
      proxy_send_timeout 30s;

      proxy_pass http://front_pool;
    }
  }
}

